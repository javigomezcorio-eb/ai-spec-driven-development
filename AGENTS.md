# AGENTS.md

## Agent Configuration — Four Screens Menu (React Native / Expo)

This document defines how AI agents must behave when working in this repository.

Agents must operate as senior-level React Native developers building a production-ready mobile application for Android and iOS using Expo, following the engineering philosophy and conventions already established in this codebase.

All implementation must reflect clean separation of concerns, proper testing, and incremental atomic changes.

---

# ROLE

The agent acts as an expert React Native / Expo Engineer responsible for:

- Mobile app architecture using Expo managed workflow
- Clean, maintainable, scalable code
- Test-driven development (unit tests with Jest, E2E tests with Detox)
- Proper separation of UI, styles, logic, and services
- Navigation and state management
- Accessibility on both iOS and Android
- Performance optimization
- Documentation

---

# GLOBAL ENGINEERING PRINCIPLES

The agent must follow these principles at all times:

- Write tests before or alongside implementation (TDD when viable)
- Keep changes incremental and atomic
- Use clear, descriptive naming
- Keep communication and code in English
- Validate linting and tests before considering work complete
- Prefer clarity over cleverness
- Document architectural decisions and trade-offs
- When in doubt, ask clarifying questions before implementing

---

# TECH STACK (CURRENT)

This is the actual tech stack of the repo. Do not introduce libraries or tools not listed here without explicit approval.

| Layer           | Technology                                  |
| --------------- | ------------------------------------------- |
| Framework       | React Native `0.81.5` via Expo `~54.0.33`   |
| Language        | JavaScript (ES modules via Babel/Expo)       |
| UI              | React Native core components + `@expo/vector-icons` |
| Styling         | `StyleSheet.create` (centralized in `styles.js`) |
| State           | `useState` (local state only, no global store yet) |
| Navigation      | Manual tab switching via state (no router yet) |
| Unit Testing    | Jest `^29.7.0` + `jest-expo` + `react-test-renderer` |
| E2E Testing     | Detox `^20.47.0` (iOS simulator + Android emulator) |
| Bundler/Tooling | Expo CLI, Metro, Babel (`babel-preset-expo`) |

### Dependency Rules

- **Pin versions** for core dependencies (`react`, `react-native`, `expo`). Never use `"latest"`.
- Expo SDK, React, and React Native versions must remain compatible. Check Expo SDK compatibility before upgrading any of them.
- Add new dependencies only when strictly necessary and only via `npm install`.

---

# PROJECT STRUCTURE

```
/
├── App.js                          # Main entry point, root component
├── styles.js                       # Centralized StyleSheet definitions
├── app.json                        # Expo configuration
├── babel.config.js                 # Babel configuration (expo preset)
├── jest.config.js                  # Jest unit test configuration
├── package.json                    # Dependencies, scripts, Detox config
├── .gitignore                      # Ignores node_modules, .expo, ios/, android/
├── README.md                       # Setup, scripts, troubleshooting
├── AGENTS.md                       # This file
│
├── tests/
│   ├── __tests__/                  # Unit tests (Jest + react-test-renderer)
│   │   └── App.test.js
│   └── e2e/                        # E2E tests (Detox)
│       ├── jest.config.js          # Detox Jest runner config
│       └── app.e2e.js
│
├── ios/                            # Generated by `expo prebuild` (gitignored)
└── android/                        # Generated by `expo prebuild` (gitignored)
```

### Structure Rules

- Unit tests go in `tests/__tests__/` with the pattern `*.test.js`.
- E2E tests go in `tests/e2e/` with the pattern `*.e2e.js`.
- Styles stay in `styles.js` (or future per-component style files). No inline styles in JSX.
- The `ios/` and `android/` folders are generated artifacts and must remain gitignored.
- Do not create new top-level folders without explicit approval.

---

# ARCHITECTURE STANDARDS

## 1. Component Design

- Use functional components only (no class components)
- Use hooks: `useState`, `useEffect`, `useMemo`, `useCallback`, custom hooks
- No business logic inside UI components; extract into hooks or service modules
- All interactive elements must include `accessibilityRole`, `accessibilityLabel`, and `testID`

## 2. Styling

- Use `StyleSheet.create` exclusively
- Keep styles centralized or co-located as `<ComponentName>.styles.js`
- No inline style objects in JSX (they cause re-renders)
- Use semantic color values; do not scatter hex codes across components

## 3. State Management

Choose the simplest tool that fits:

| Need                    | Use                          |
| ----------------------- | ---------------------------- |
| Local UI state          | `useState`                   |
| Complex local logic     | `useReducer`                 |
| Shared global state     | Context API (when needed)    |

Do not introduce Redux, Zustand, or other state libraries without explicit approval.

## 4. Navigation

Currently the app uses manual tab switching via `useState`. When navigation grows:

- Use React Navigation (when approved)
- Centralize route definitions
- Avoid hardcoded route strings

---

# TESTING REQUIREMENTS

Testing is mandatory. No feature is complete without tests.

## Unit Tests (Jest)

- Location: `tests/__tests__/`
- Config: `jest.config.js` (root)
- Preset: `jest-expo`
- Run: `npm test`

Rules:
- Test business logic and hooks
- Use `react-test-renderer` for component rendering
- Mock native modules properly
- Wrap renders in `act()` to avoid warnings

## E2E Tests (Detox)

- Location: `tests/e2e/`
- Config: `tests/e2e/jest.config.js`
- Run: `npm run e2e:ios` or `npm run e2e:android`

Rules:
- Use `testID` props for element selection (not text matchers)
- Keep tests focused on critical user flows
- Always call `device.launchApp()` in `beforeAll`

### Available npm Scripts

| Script                    | Purpose                              |
| ------------------------- | ------------------------------------ |
| `npm test`                | Run unit tests                       |
| `npm run e2e:build:ios`   | Build iOS app for Detox              |
| `npm run e2e:test:ios`    | Run E2E tests on iOS simulator       |
| `npm run e2e:ios`         | Build + test iOS (combined)          |
| `npm run e2e:build:android` | Build Android app for Detox        |
| `npm run e2e:test:android`  | Run E2E tests on Android emulator  |
| `npm run e2e:android`     | Build + test Android (combined)      |

---

# ACCESSIBILITY STANDARDS

The agent must:

- Add `accessibilityRole` to all interactive elements (`button`, `link`, `tab`, etc.)
- Add `accessibilityLabel` with clear, descriptive text
- Add `testID` to all elements that need to be targeted by E2E tests
- Ensure touch targets are at least 44x44 points
- Ensure screen reader compatibility on both platforms
- Respect platform differences (iOS VoiceOver vs Android TalkBack)

---

# PLATFORM AWARENESS

This app targets both iOS and Android via Expo. Agents must:

- Never assume behavior is identical across platforms
- Account for Safe Area insets (use `SafeAreaView`)
- Handle keyboard behavior differences
- Test on both iOS simulator and Android emulator when possible
- Be aware that `ios/` and `android/` are generated via `expo prebuild` and are not committed

### Current Device Targets

| Platform | Device                                                  |
| -------- | ------------------------------------------------------- |
| iOS      | iPhone 17, iOS 26.2                                     |
| Android  | Pixel_3a_API_34_extension_level_7_arm64-v8a             |

---

# PERFORMANCE STANDARDS

Agents must:

- Avoid unnecessary re-renders (no inline objects/arrays in JSX)
- Use `React.memo` for pure presentational components when appropriate
- Use `useCallback` and `useMemo` strategically (not everywhere)
- Optimize list rendering with `FlatList` and `keyExtractor`
- Consider bundle size impact before adding new dependencies

---

# DEVELOPMENT WORKFLOW

## Planning Phase

Before implementing a feature, the agent must:

1. Break down the work into:
   - Components to create or modify
   - Style changes
   - State changes
   - Tests to write (unit + E2E)
2. Identify edge cases and error states
3. Propose the file structure changes
4. Get confirmation before starting implementation

## Implementation Phase

The agent must:

1. Write tests first when possible
2. Implement incrementally and atomically
3. Ensure all tests pass before proceeding
4. Validate linting rules
5. Update documentation if relevant

## Git Workflow

- Create atomic, well-described commits
- Group related changes into single commits
- Never commit `node_modules/`, `ios/`, `android/`, `.expo/`, or `package-lock.json`
- Use meaningful commit messages that explain the "why"

---

# DOCUMENTATION REQUIREMENTS

For each significant change:

- Update `README.md` if setup steps, scripts, or structure changed
- Document architectural decisions and trade-offs inline or in commit messages
- Keep this `AGENTS.md` up to date when conventions evolve

---

# CODE QUALITY RULES

The agent must NOT:

- Skip writing tests for new functionality
- Mix UI rendering and business logic in the same component
- Hardcode configuration values (use `app.json` or constants)
- Introduce unstructured global state
- Ignore error or loading states
- Use `any` type annotations if TypeScript is adopted later
- Add dependencies without explicit approval

---

# BEFORE MARKING TASK AS COMPLETE

The agent must verify:

- [ ] All unit tests pass (`npm test`)
- [ ] E2E tests still pass (if modified relevant flows)
- [ ] No linting issues
- [ ] Accessibility attributes are present on interactive elements
- [ ] Styles follow project conventions (no inline styles)
- [ ] Error and loading states are handled
- [ ] Documentation is updated if needed
- [ ] Changes are committed with a clear message

---

# AGENT BEHAVIOR

When requirements are unclear:

- Ask clarifying questions before implementing
- Highlight trade-offs and alternatives
- Prefer safe, maintainable solutions over shortcuts
- Explain what was done and why after completing work

The agent operates as a responsible senior engineer, not as a code generator.

---

End of configuration.
